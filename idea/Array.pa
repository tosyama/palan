int n=10;
[10]int64 a;	// 10の固定配列(要素数はコンパイラが管理/Cと同等)

[]int64 au = [1..10];	// 10の固定配列(要素数はコンパイラが管理/Cと同等)

[#n]int64 b;		// 未定要素数の固定配列(要素数は配列アドレスの一つ前に管理/Cに渡せる)
[#10]int64 c;		// あえて明示未定要素数の固定配列(要素数は配列アドレスの一つ前に管理)
[+3]int64 aa;	// 可変配列(メンバーとして要素アドレス, 要素数をもつ※要素アドレス不定のためCと互換性なし)

[4,3]int64 m;	// 3x4の固定配列 (メモリ上は [3][3][3][3])
				// access : a[y,x] = a[y][x];

[#4,3]int64 mb;	// 3x4の要素数未定固定配列 (メモリ上は #3#4[3][3][3][3])
					// メンバーに一つでも#があれば要素数未定配列となる
				// int64[#y,x] != int64[#x][#y]
				// #x#y[x][x]...  != #y[(#x[x]),(#x[x])...
[+][+]int64 mm;	// 可変配列の可変配列
[4,3][+]int64 mmm;	// 可変配列の固定長配列(メモリ上は[][]...)

[3]@int64 ref; //整数の参照の配列
@[3]int64 ref; //固定配列の参照 (int64->[3]->*)
@[?]int64 cref; //要素数未管理配列への参照(Cのポインタ同等) (int64->[?]->*)
[3]@[3]int64 ref; //固定配列の参照の配列 (int64->[3]->*->[3])
[4]@@[3]int64 ref; //固定配列の参照の参照の配列(参照の参照をゆるす?)
[3]@[3]@int64 ref; //参照の配列の参照の配列 (int64->*->[3]->*->[3])

// 初期化例
[,]int64 m1 = [1,2,3,4][5,6,7,8][9,10,11,12]; // no camma between dim.

[3,4]int64 m2 = [1..12];
[#n,4]int64 m2a = [1..4*n];

[#3,4]int64 m3 = 0; // all 0;
[+][+]int64 m4 = [[1,2,3,4],[3],[2,3,4]]; // need camma.

// 代入パターン
[3]int64 a3 = [1,2,3];
[5]int64 a5 = [9,9,9,9,9];
[3]int32 b3 = [1,2,3];

// ok
[5,6,7] -> a5[2:];	// [9,9,5,6,7]
a3 -> a5; // [1,2,3,6,7]
7->a5[2];
a5 -> a3; // [1,2,7]
a3 -> a5[2:]; // [1,2,1,2,7]

// NG?
// b3->a3;	// [1,2,3]?


func setArray(=>[10]int64 a, [#]int64 b, [+]int64 aa, [3,4]int64m, [+][+]int64 mm)
{
}
