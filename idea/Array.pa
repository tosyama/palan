int n=10;
int64[10] a;	// 10の固定配列(要素数はコンパイラが管理/Cと同等)

int64[] au = [1..10];	// 10の固定配列(要素数はコンパイラが管理/Cと同等)

int64[#n] b;		// 未定要素数の固定配列(要素数は配列アドレスの一つ前に管理/Cに渡せる)
int64[#10] c;		// あえて明示未定要素数の固定配列(要素数は配列アドレスの一つ前に管理)
int64[+3] aa;	// 可変配列(メンバーとして要素アドレス, 要素数をもつ※要素アドレス不定のためCと互換性なし)

int64[4,3] m;	// 3x4の固定配列 (メモリ上は [3][3][3][3])
				// access : a[y,x] = a[y][x];

int64[#4,3] mb;	// 3x4の要素数未定固定配列 (メモリ上は #3#4[3][3][3][3])
					// メンバーに一つでも#があれば要素数未定配列となる
				// int64[#y,x] != int64[#x][#y]
				// #x#y[x][x]...  != #y[(#x[x]),(#x[x])...
int64[+][+] mm;	// 可変配列の可変配列
int64[4,3][+] mmm;	// 可変配列の固定長配列(メモリ上は[][]...)

int64([3]*) ref; //整数の参照の配列
int64(*[3]) ref; //固定配列の参照 (int64->[3]->*)
int64(*[?]) cref; //要素数未管理配列への参照(Cのポインタ同等) (int64->[?]->*)
int64([3]*[3]) ref; //固定配列の参照の配列 (int64->[3]->*->[3])
int64([4]**[3]) ref; //固定配列の参照の参照の配列(参照の参照をゆるす?)
int64([3]*[3]*) ref; //参照の配列の参照の配列 (int64->*->[3]->*->[3])

// 初期化例
int64[,] m1 = [[1,2,3,4]
					[5,6,7,8]
					[9,10,11,12]]; // no camma between dim.
int64[3,4] m2 = [1..12];
int64[#n,4] m2a = [1..4*n];

int64[#3,4] m3 = 0; // all 0;
int64[+][+] m4 = [[1,2,3,4],[3],[2,3,4]]; // need camma.

func int64[10] a, int64[#] b, int64[+] aa, int64[3,4]m, int64[+][+] mm
	setArray(&a, &b, &aa, &m, &mm)
{
}

func omitParamType(int64[10] &a, b, *c)
{
}

